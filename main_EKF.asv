%% Main Function for EKF Analysis
close all; clear; clc;

%% EKF
Data = load('cooplocalization_finalproj_KFdata.mat');

% Ode values
options = odeset('RelTol', 1e-8, 'AbsTol', 1e-10);

% Test the EKF update
% Nominal values
x_ugv = [10; 0; pi/2];
x_uav = [-60; 0; -pi/2];
u_ugv = [2; -pi/18];
u_uav = [12; pi/25];

x_nom = [x_ugv; x_uav];
u_nom = [u_ugv; u_uav];

% Time step
dt = 0.1;

xhat_prev = x_nom;
u = u_nom;
y = sensors(xhat_prev);
Q = Data.Qtrue;
R = Data.Rtrue;
P_prev = [10, 0, 0, 0, 0, 0;
            0, 10, 0, 0, 0, 0;
            0, 0, pi, 0, 0, 0;
            0, 0, 0, 10, 0, 0;
            0, 0, 0, 0, 10, 0;
            0, 0, 0, 0, 0, pi];

%[xhat_meas, P_meas] = EKF(xhat_prev, P_prev, u, y, dt, Q, R);

% Truth model testing, get true state and data
n_ind = 1000;
[time_tmt, x_noise_mat, y_noise_mat] = simulateNoise(x_nom, u_nom, Q, R, dt, n_ind);

% Simulate nonlinear equations to get deterministic state trajectory
num_measurements = 10;
[xhat_final, P_final] = NLLS(u, y_noise_mat, num_measurements, Q, R, dt);




% Output the final xhat measurement
% disp('Final Initial State Estimate:');
% disp(xhat_final);
% 
% disp('Final Covariance Estimate:');
% disp(P_final);

% Run the EKF with an initial guess and covariance
x_init = x_noise_mat(1,:);
P_init = diag([1000, 1000, 2*pi, 1000, 1000, 2*pi]);

% Tune the Q and R matrices
Q = Q;
R = R;

% Estimated and covariance matrices
xhat_mat = zeros(length(y_noise_mat(:,1)), 6);
P_mat = zeros(length(y_noise_mat(:,1)), 6);

% Loop over the noisy measurements to get the estimates
xhat_curr = x_init;
P_curr = P_init;
for i = 1:length(y_noise_mat(:,1))
    % Get the current measurement
    y_meas = y_noise_mat(i,:)';

    % Kalman update
    [xhat_meas, P_meas] = EKF(xhat_curr, P_curr, u_nom, y_meas, dt, Q, R);

    % Store the result in a matrix of the estimated state;
    xhat_mat(i, :) = xhat_meas';
    P_mat(i,:) = sqrt(diag(P_curr))';
end




% Plot the results
figure();
plot()








